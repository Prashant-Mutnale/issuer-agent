"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAgainstCredential = exports.isIStream = exports.fromCredential = exports.verifyDataStructure = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@cord.network/utils");
const Did = tslib_1.__importStar(require("@cord.network/did"));
const Credential = tslib_1.__importStar(require("../credential/index.js"));
/**
 *  Checks whether the input meets all the required criteria of an [[IStream]] object.
 *  Throws on invalid input.
 *
 * @param input The potentially only partial [[IStream]].
 *
 */
function verifyDataStructure(input) {
    if (!input.identifier) {
        throw new utils_1.SDKErrors.IdentifierMissingError();
    }
    utils_1.DataUtils.validateId(input.identifier, 'Stream Identiifier');
    if (!input.schema) {
        throw new utils_1.SDKErrors.SchemaMissingError();
    }
    utils_1.DataUtils.validateId(input.schema, 'Schema Identifier');
    if (!input.streamHash) {
        throw new utils_1.SDKErrors.StreamHashMissingError();
    }
    utils_1.DataUtils.verifyIsHex(input.streamHash, 256);
    if (!input.issuer) {
        throw new utils_1.SDKErrors.IssuerMissingError();
    }
    Did.validateUri(input.issuer, 'Did');
    if (typeof input.revoked !== 'boolean') {
        throw new utils_1.SDKErrors.RevokedTypeError();
    }
}
exports.verifyDataStructure = verifyDataStructure;
/**
 * Builds a new instance of an [[Stream]], from a complete set of input required for an stream.
 *
 * @param content - The base request for stream.
 * @param creatorPublicIdentity - Public Identity of the issuer, used to anchor the underlying stream.
 * @returns A new [[Stream]] object.
 *
 */
function fromCredential(content) {
    const stream = {
        identifier: content.identifier,
        streamHash: content.rootHash,
        issuer: content.content.issuer,
        schema: content.content.schemaId,
        registry: content.registry,
        revoked: false,
    };
    verifyDataStructure(stream);
    return stream;
}
exports.fromCredential = fromCredential;
/**
 * Custom Type Guard to determine input being of type IStream using the StreamUtils errorCheck.
 *
 * @param input The potentially only partial IStream.
 * @returns Boolean whether input is of type IStream.
 */
function isIStream(input) {
    try {
        verifyDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isIStream = isIStream;
/**
 * Verifies whether the data of the given attestation matches the one from the corresponding credential. It is valid if:
 * * the [[Credential]] object has valid data (see [[Credential.verifyDataIntegrity]]);
 * and
 * * the hash of the [[Credential]] object, and the hash of the [[Stream]].
 *
 * @param stream - The stream to verify.
 * @param credential - The credential to verify against.
 */
function verifyAgainstCredential(stream, credential) {
    const schemaMismatch = credential.content.schemaId !== stream.schema;
    const credentialMismatch = credential.rootHash !== stream.streamHash;
    if (credentialMismatch || schemaMismatch) {
        throw new utils_1.SDKErrors.CredentialUnverifiableError(`Some attributes of the stream diverge from the credential: ${[
            'schemaId',
            'streamHash',
        ]
            .filter((_, i) => [schemaMismatch, credentialMismatch][i])
            .join(', ')}`);
    }
    Credential.verifyDataIntegrity(credential);
}
exports.verifyAgainstCredential = verifyAgainstCredential;
